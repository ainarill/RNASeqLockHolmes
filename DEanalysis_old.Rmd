---
output:
  BiocStyle::html_document
---

<!---
Because we split the analysis pipeline in different independent files,
to speed up processing it, here in the setup block we load libraries and
objects that were loaded or produced in the previously processed file,
and which are necessary in this file.
--->



```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)
library(SummarizedExperiment)
library(edgeR)
library(geneplotter)


opts_chunk$set(cache=TRUE,
               cache.path="cache/file2",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")

coadse <- readRDS(file.path("rawCounts", "seCOAD.rds"))
dge <- readRDS(file.path("results", "dge.rds"))
coadse.filt.unnorm <- readRDS(file.path("results", "coadse.filt.unnorm.rds"))
dge.filt.unnorm <- readRDS(file.path("results", "dge.filt.unnorm.rds"))
coadse.filt <- readRDS(file.path("results", "coadse.filt.rds"))
dge.filt <- readRDS(file.path("results", "dge.filt.rds"))


```

# Differential expression


The following step is to perform a simple examination of expression changes and their associated p-values using the R/Bioconductor package [sva](http://bioconductor.org/packages/sva) as follows:

```{r, message=FALSE}
library(sva)
tss <- substr(colnames(dge.filt), 6, 7)
mod <- model.matrix(~ coadse.filt$type + tss, colData(coadse.filt))
mod0 <- model.matrix(~tss, colData(coadse.filt))
pv <- f.pvalue(assays(coadse.filt)$logCPM, mod, mod0)
sum(p.adjust(pv, method="fdr") < 0.01)
```

There are `r sum(p.adjust(pv, method="fdr") < 0.01)` genes changing significantly
their expression at FDR < 1%. In Figure \@ref(fig:pdist) below we show the distribution of the
resulting p-values.

```{r pdist, echo=FALSE, out.width="400px", fig.cap="Distribution of raw p-values for an F-test on every gene between tumor and normal samples."}
hist(pv, main="", las=1)
```


Then we are going to estimate surrogate variables using the `sva()` function.

```{r}
sv <- sva(assays(coadse.filt)$logCPM, mod, mod0)
sv$n
```

The SVA algorithm has found `r sv$n` surrogate variables. So, we are going to use them to
assess againt the extent of differential expression this time adjusting for these
surrogate variables.

```{r}
modsv <- cbind(mod, sv$sv)
mod0sv <- cbind(mod0, sv$sv)
pvsv <- f.pvalue(assays(coadse.filt)$logCPM, modsv, mod0sv)
sum(p.adjust(pvsv, method="fdr") < 0.01)
```

We have increased the number of changing genes to `r sum(p.adjust(pvsv, method="fdr") < 0.01)`.
Figure \@ref(fig:psvdist) shows the resulting distribution of p-values.

```{r psvdist, echo=FALSE, out.width="400px", fig.cap="Distribution of raw p-values for an F-test on every gene between tumor and normal samples, adjusting for surrogate variables estimated with SVA."}
hist(pvsv, main="", las=1)
```
```{r}
v1 <- voom(dge.filt, mod, plot=TRUE)
fit1 <- lmFit(v1, mod)
fit1 <- eBayes(fit1)
FDRcutoff = 0.1
res1 <- decideTests(fit1, p.value = FDRcutoff)
summary(res1)
tt1 <- topTable(fit1, coef = 2, n = Inf) 
head(tt1)
```


```{r}
# it works - names need to be changed
library(sva)
tss <- substr(colnames(dge.filt), 6, 7)
pid<-substr(colnames(dge.filt), 9, 12)
pid
mod <- model.matrix(~ coadse.filt$type + tss + gender, colData(coadse.filt))
mod0 <- model.matrix(~tss, colData(coadse.filt))
pv <- f.pvalue(assays(coadse.filt)$logCPM, mod, mod0)
sum(p.adjust(pv, method="fdr") < 0.01)
sv <- sva(assays(coadse.filt)$logCPM, mod, mod0)
modsv <- cbind(mod, sv$sv)
mod0sv <- cbind(mod0, sv$sv)
pvsv <- f.pvalue(assays(coadse.filt)$logCPM, modsv, mod0sv)
sum(p.adjust(pvsv, method="fdr") < 0.01)
v1 <- voom(dge.filt, mod, plot=TRUE)
fit1 <- lmFit(v1, mod)
fit1 <- eBayes(fit1)
FDRcutoff = 0.1
res1 <- decideTests(fit1, p.value = FDRcutoff)
summary(res1)
tt1 <- topTable(fit1, coef = 2, n = Inf) 
head(tt1)
```




## -----------------------------
## Differential expression analysis

We used linear regression models to approach the differential expression (DE) analysis; for this purpose we used the R package "limma", which is widely used and well documented.

 !!!! Se tiene q redactar de verdad
 
Linear regression models are used in order to represent, in the most accurate way possible, something which is very complex. In the specific case of DE analysis, the linear regression is used as a predictor of gene expression values. 
For the purpose of fitting the said regression model, it is then crucial to build a design matrix in order to solve the system of equations (as many equations as type of samples). The design matrix is a n x m matrix, where n is the number of samples and m is the number of coeffients which need to be estimated or the types of samples, like case and controls; it basically contains the information about which coefficient will be set to 0 in order to observe the difference of expression for the other one.
In the following step we proceed with the building of the design matrix. 


```{r}
library(sva)
patientid <- substr(colnames(dge.filt), 9, 12)
mod1 <- model.matrix(~ coadse.filt$type+tss+patientid, colData(coadse.filt))
mod01 <- model.matrix(~tss, colData(coadse.filt))
pv1 <- f.pvalue(assays(coadse.filt)$logCPM, mod1, mod01)
sum(p.adjust(pv1, method="fdr") < 0.01)
hist(pv1, main="", las=1)
sv1 <- sva(assays(coadse.filt)$logCPM, mod1, mod01)
sv$n
mod1sv <- cbind(mod1, sv1$sv)
mod01sv <- cbind(mod01, sv1$sv)
colnames(mod01sv) <- c(colnames(mod01)[1:4], paste0("SV", 1:sv1$n))
pvsv1 <- f.pvalue(assays(coadse.filt)$logCPM, mod1sv, mod01sv)
sum(p.adjust(pvsv1, method="fdr") < 0.01)
hist(pvsv, main="", las=1)
```

```{r}
fit4 <- lmFit(assays(lclse)$logCPM, mod)
```


```{r}
mod1 <- model.matrix(~type + bcr_patient_barcode + tss , data = colData(coadse.filt))
mod01 <- model.matrix(~bcr_patient_barcode + tss , data = colData(coadse.filt))
mod2 <- model.matrix(~type + bcr_patient_barcode +tss+gender  , data = colData(coadse.filt))
mod02 <- model.matrix(~ bcr_patient_barcode +tss+gender  , data = colData(coadse.filt))
```
```{r}
library(sva)
sv <- sva(assays(coadse.filt)$logCPM, mod = mod, mod0 = mod0)

```

```{r}
sv <- sva(assays(coadse.filt)$logCPM, mod = mod, mod0 = mod0)
```
The next step is to Adjust for the mean-variance realtionship. Two main methods are currently available. We decide to proceed with the voom() function, since as we can observe in the picture below, there are big differences in sample sizes among the samples.
```{r}
barplot(sort(dge.filt$samples$lib.size)/1e+06, xlab = "Samples", ylab = "Library sizes (Millions)")
```
```{r}
v1 <- voom(dge.filt, mod1, plot=TRUE)
v2 <- voom(dge.filt, mod2, plot=TRUE)
```

Next, we estimate correlation in repeated measurements of a blocking factor
The function lmfit fits a linear model for each gene given a series of arrays

```{r}
fit1<- lmFit(v1,mod1)
fit2<- lmFit(v2,mod2)

```

```{r}
fit <- eBayes(fit1)
topTable(fit , coef = 2, n = Inf)
```

```{r}
plot(r, p, pch=21:26, bg="black", xlab="Recall", ylab="Precision", las=1)
Fsteps <- seq(0.05, 0.95, by=0.01)
Fticks <- c()
for (f in Fsteps) {
  allr <- seq(0.05, 1, by=0.01)
  allp <- (-allr*f)/(f-2*allr)
  allr <- allr[allp >= 0]
  allp <- allp[allp >= 0]
  lines(allr, allp, type="l", lwd=2, lty=3, col="grey")
  Fticks <- c(Fticks, (-par("usr")[2]*f)/(f-2*par("usr")[2]))
}
axis(4, at=Fticks, labels=sprintf("%.2f", Fsteps), las=1)
mtext("F-measure", side=4, line=3)
legend("top", legend=paste("Model", 1:6), pch=c(1, 21:25),
       pt.bg="black", bg="white", inset=0.05)
```

```{r}
dim(coadse.filt)
summary(coadse.filt$age_at_initial_pathologic_diagnosis)
```

## Session information

```{r, message=FALSE}
sessionInfo()
```
