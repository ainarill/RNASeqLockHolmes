---
output:
  BiocStyle::html_document
---

<!---
The following chunk of code, which should not be shown in the resulting document (echo=FALSE)
sets up global processing options, such as forcing 'knitr' to stop when an error
in the R code is encountered, caching of the results in the 'cache'
directory and asking 'knitr' to figure out automatically the dependencies among
code chunks to re-calculate cached results (autodep=TRUE).

Other options could be changing the name of the directory where figures end up
('figure' by default), etc. For a full account of 'knitr' options please consult
http://yihui.name/knitr/options

At the end of the chunk a 'cat()' call is made to dump a CSS file that gives
a better look-and-feel than the knitr default one. See the source css/ieo.css
and the resulting projectTemplate.html to understand where this is being dumpted.
--->


```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)

opts_chunk$set(cache=TRUE,
               cache.path="cache/QA",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")
```

# Quality assessment

## Data import

We start importing the raw table of counts.

<!--
The option 'message=FALSE' avoid dumping R messages such as "Loading required package: methods"
into the output of the report.
-->

```{r, message=FALSE}
library(SummarizedExperiment)
coadse <- readRDS(file.path("rawCounts", "seCOAD.rds"))
coadse
```

In this TCGA RNA-seq data we have a total of 524 samples (483 tumor samples and 41 non-tumor samples). 
In order to know more about the data, we explore the `colData` column, that corresponds to clinical
variables, and their corresponding metadata.

```{r}
dim(colData(coadse))
```
We have a total of 524 samples that have 549 clinical variables/factors that could be analysed. However,
we are not going to explore all these variables, but those that can have more relenace in the data of study.
```{r}
colData(coadse)[1:5, 1:5]
```
```{r}
mcols(colData(coadse), use.names=TRUE)
```
These metadata consists of two columns of information about the clinical variables.
One called `labelDescription` contains a succint description of the variable, often
not more self-explanatory than the variable name itself, and the other called
'CDEID' corresponds to the so-called `Common Data Element (CDE)` identifier. This
identifier can be use in https://cdebrowser.nci.nih.gov to search for further
information about the associated clinical variable using the `Advanced search`
form and the `Public ID` attribute search.

Now, explore the row (feature) data. 

```{r}
rowData(coadse)
```
```{r}
rowRanges(coadse)
```
By using the `rowData` and `rowRanges` functions we can see information about the
features of interest. In this case each row represents a gene transcript and we 
can see information about the length, the GC content, the chromosome where it is 
located, the strand (forward or reverse), etc. 

To perform quality assessment and normalization we need first to load the
[edgeR](http://bioconductor.org/packages/edgeR) R/Bioconductor package, 
create a `DGEList` object and store it in the `results` folder.

```{r, message=FALSE}
library(edgeR)
dge <- DGEList(counts=assays(coadse)$counts, genes=mcols(coadse))
saveRDS(dge, file.path("results", "dge.rds"))
```

Now calculate $\log_2$ CPM values of expression and put them as an additional
assay element to ease their manipulation. 

```{r}
assays(coadse)$logCPM <- cpm(dge, log=TRUE, prior.count=0.5)
assays(coadse)$logCPM[1:5, 1:5]
```
As we can see, for each sample there are different CPM (Counts Per Million) values
of expression. Negative ones correspond to very low expressed samples. 

## Subset of samples: Paired Analysis

From the total of 524 samples, before starting to analyse the data we proceed to do a subset of paired samples (tumor and non-tumor samples extracted from the same patient). The reason of doing this is to reduce the within variance, as far as variation between different individuals could be found due to environmental factors. In order to a better estimate of these expression level differences between Tumor and Non-tumor samples, we searched in the [TCGA barcode](https://docs.gdc.cancer.gov/Encyclopedia/pages/TCGA_Barcode/) those patients that were present in both Tumor and Non-tumor samples. This meant that those samples belonged to the same patient and, thus, were paired.

```{r}
CODE FOR PAIRED SAMPLE SUBSET!!
```

## Sequencing depth

Before proceeding with any normalization or analysis step, we want to collect an overview of
the data that we are working with. Here we examine the sequencing depth by plotting the total number of
reads mapped to the genome per sample.

```{r libsizes, echo=FALSE, out.width="600px", fig.cap="Library sizes in increasing order."}
sampledepth <- round(dge.paired$sample$lib.size / 1e6, digits=1)
names(sampledepth) <- substr(colnames(coadse.paired), 6, 12)
sort(sampledepth)
par(mfrow = c(1, 1), mar = c(4, 5, 1, 1))
ord <- order(dge.paired$sample$lib.size)
barplot(dge.paired$sample$lib.size[ord]/1e+06, las = 1, ylab = "Millions of reads", xlab = "Samples",
        col = c("cyan", "orange")[coadse.paired$type] )
legend("topleft", c("Normal", "Tumor"), fill = c("cyan", "orange"), inset = 0.01)
```
In the plot we observe two main aspects that are worth paying attention to.
First, we observe that surprisingly all the tumor samples present a lower sequencing depth than the
normal samples. Even though we could not find any reliable explaination for this behaviour so far in our
research, we considered this event dispensable at this time as the sequencing depth will be taken into 
consideration during the normalization steps.
One other important aspect is that we observe that some sample present considerable differences in the sequencing depth
and specifically we can distinguish a couple of samples on the left of the graph that present 
considerably low sequencing depths: this may generate problems in further analysis of the data. 
For this reason we identify these samples by looking at the at the sample depth as shown below. 
```{r}
sampledepth <- round(dge.paired$sample$lib.size / 1e6, digits=1)
names(sampledepth) <- substr(colnames(coadse.paired), 6, 12)
sort(sampledepth)
```
Because the samples A6.2679 and A6.2682 present extremely low sequencing depths we decide to remove them from our dataset.
Since we decided to proceed with a paired analysis, when removing one sample we remove its paired one too.

```{r}
# Remove the two samples with very low sequencing depth
mask_remove_low_coverage <- substr(colnames(coadse.paired),9,12) %in% c("2679", "2682")
coadse.paired <- coadse.paired[,!mask_remove_low_coverage]
dge.paired <- dge.paired[,!mask_remove_low_coverage]
dim(coadse.paired)
```

Here we can observe again the same plot as before after having removed the said samples.

```{r}
# coverage_filtered plot
names(sampledepth) <- substr(colnames(coadse.paired), 6, 12)
sort(sampledepth)
par(mfrow = c(1, 1), mar = c(4, 5, 1, 1))
ord <- order(dge.paired$sample$lib.size)
barplot(dge.paired$sample$lib.size[ord]/1e+06, las = 1, ylab = "Millions of reads", xlab = "Samples",
        col = c("cyan", "orange")[coadse.paired$type] )
legend("topleft", c("Normal", "Tumor"), fill = c("cyan", "orange"), inset = 0.01)
```

## Gender among samples
In order to collect an even broader understanding of the dataset we then furher explore the sequencing 
depth highlighting female and male samples.

```{r}
ord <- order(dge.paired$sample$lib.size)
barplot(dge.paired$sample$lib.size[ord]/1e+06, las = 1, ylab = "Millions of reads", xlab = "Samples",
        col = c("cyan", "orange")[coadse.paired$gender[ord]] )
legend("topleft", c("Female", "Male"), fill = c("cyan", "orange"), inset = 0.01)
```
In the figure we can see that not only we have a similar number of female and male samples, but that 
their sequencing depth is quite well equilibrated as we cannot clearly identify any defined clustering event.

## Distribution of expression levels among samples

We first run a within sample normalization. 
```{r}
CPM <- t(t(dge.paired$counts)/(dge.paired$samples$lib.size/1e+06))
assays(coadse.paired)$logCPM <- cpm(dge.paired, log = TRUE, prior.count = 0.25) 
```

We are then interested in exploring the distribution of the expression levels through
all the samples in terms of logarithmic CPM units.
```{r disrRawExpAll, echo=FALSE, fig.height=4, fig.width=10, out.width="800px", fig.cap="Non-parametric density distribution of expression profiles per sample.", message=FALSE}
par(mfrow = c(1, 1), mar = c(4, 5, 1, 1))
multidensity(as.list(as.data.frame(assays(coadse.paired)$logCPM)), xlab = "log2 CPM", legend = NULL,
             main = "All samples", cex.axis = 1.2, cex.lab = 1.5, las = 1)
```
In order to provide a clearer visualization, we decided to devide the dataset into two smaller subsets, specifically 
tumor samples and normal sample. Figure \@ref(fig:distRawExpComp) shows the expression levels in terms of logCPM for tumors
and control samples separately.
```{r disrRawExpComp, echo=FALSE, fig.height=4, fig.width=10, out.width="800px", fig.cap="Non-parametric density distribution of expression profiles per sample.", message=FALSE}
tumor_mask <- coadse.paired$type == "tumor"
non_tumor_mask <- coadse.paired$type == "normal"
coadse_tumor <- coadse.paired[,tumor_mask]
coadse_control <- coadse.paired[,non_tumor_mask]
# plot divided by tumor and control for a better overview
par(mfrow = c(1, 2), mar = c(4, 5, 1, 1))
multidensity(as.list(as.data.frame(assays(coadse_tumor)$logCPM)), xlab = "log2 CPM", legend = NULL,
           main = "Tumor samples", cex.axis = 1.2, cex.lab = 1.5, las = 1)
multidensity(as.list(as.data.frame(assays(coadse_control)$logCPM)), xlab = "log2 CPM", legend = NULL,
             main = "Control samples", cex.axis = 1.2, cex.lab = 1.5, las = 1)
```

As we do not observe extreme differences in the distribution of the expression values we decide to not exclude any sample
from the dataset in this step and to proceed with furthe analyses with the current dataset.


## Distribution of expression levels among genes

We are now interested in investigating if there is any gene which has very low expression
values so that we can possibly want to exclude them from the dataset.
In order to do so, we calculate the average expression of each gene for all the samples and plot
their distribution in Figure \@ref(fig:exprdist).

```{r exprdist, echo=FALSE, out.width="400px", fig.cap="Distribution of average expression level per gene."}
avgexp <- rowMeans(assays(coadse.paired)$logCPM)
par(mfrow = c(1, 1), mar = c(4, 5, 1, 1))
hist(avgexp, xlab = expression(log[2] * "CPM"), main = "", las = 1, col = "gray")
abline(v = 0, col = "red", lwd = 2)
```

## Filtering of lowly-expressed genes

From this distribution of  \@ref(fig:exprdist) we could already visually identify a cutoff to define the too lowly expressed genes.
Nontheless, we opted for a more precise approach to calculate the cutoff.

```{r}
cpmcutoff <- round(10/min(dge.paired$sample$lib.size/1e+06), digits = 1)
sprintf("Cutoff: %s", cpmcutoff)
nsamplescutoff <- min(table(coadse.paired$gender))
mask <- rowSums(cpm(dge.paired) > cpmcutoff) >= nsamplescutoff
coadse.filt <- coadse.paired[mask, ]
dge.filt <- dge.paired[mask, ]
dim(coadse.filt)
```

Once we have identified the cutoff, we filter out the genes that are below the said cutoff.
We can visually observe which genes have been left out from the datatset in Figure \@ref(fig:filter)
```{r filter}
par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "",
          las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
x <- cut(rowMeans(assays(coadse.filt)$logCPM), breaks = h$breaks)
lines(h$mids, table(x), type = "h", lwd = 10, lend = 1, col = "darkred")
legend("topright", c("All genes", "Filtered genes"), fill = c("grey", "darkred"))
```

Before proceeding with the normalization steps, we prefer to save a copy of the unnormalized data 
in case we later need to work on it again.
```{r}
saveRDS(se.filt, file.path("results", "se.filt.unnorm.rds"))
saveRDS(dge.filt, file.path("results", "dge.filt.unnorm.rds"))
```
## Normalization

Since different samples may have different RNA compositions and this could be problematic for further analyses
we need to take it into account and normalize the data.
We estimate a normalization factor for each library using the Trimmed Mean of M-Values and apply it
to our data.

```{r}
dge.filt <- calcNormFactors(dge.filt) 
assays(coadse.filt)$logCPM <- cpm(dge.filt, log=TRUE, normalized.lib.sizes=TRUE, prior.count=0.25)
```

Again, we like to keep on with the good practice of storing intermediate generated files.  

```{r}
saveRDS(se.filt, file.path("results", "coadse.filt.rds"))
saveRDS(dge.filt, file.path("results", "dge.filt.rds"))
```

## MA-plots

We now want to visualize the expression profiles of the normalized data. 
As we did previously, we opted for a subdivision of the dataset in the tumor and
normal subsets.
In Figure \@ref(fig:maPlotsTumor) we observe the MA-plots for the Tumor samples subset.
```{r maPlotsTumor, fig.height=36, fig.width=6, dpi=100, echo=FALSE, fig.cap="MA-plots of the tumor samples."}
par(mfrow=c(15, 3), mar=c(4, 5, 3, 1))
setmp <- coadse.filt[, coadse.filt$type == "tumor"]
dgetmp <- dge.filt[, coadse.filt$type == "tumor"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

In Figure \@ref(fig:maPlotsNormal) we observe the MA-plots for the Control samples subset.

```{r maPlotsNormal, fig.height=32, fig.width=6, dpi=100, echo=FALSE, fig.cap="MA-plots of the control samples."}
par(mfrow=c(15, 3), mar=c(4, 5, 3, 1))
setmp <- coadse.filt[, coadse.filt$type == "normal"]
dgetmp <- dge.filt[, coadse.filt$type == "normal"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

As we do not see any important expression levels biases in any of the tumor and normal samples we decide to proceed to the 
next step of the analysis without modifying the dataset we work with.

## Batch identification

The next step will be the search for potential surrogate of batch effect indicators. Batch effect include sub-groups of measurements that have qualitatively different behaviour across conditions and are unrelated to the biological variables in the study.
As normalization of the data can not always remove completely the batch effect, we are going to identify this effect, adjust it and eventually correct it.

Given that each sample names corresponds to a TCGA barcode (see https://wiki.nci.nih.gov/display/TCGA/TCGA+barcode), following the strategy described in http://bioinformatics.mdanderson.org/main/TCGABatchEffects:Overview we are going to derive different elements of the TCGA barcode and examine their distribution across samples.

```{r}
tss <- substr(colnames(dge.filt), 6, 7)
table(tss)
center <- substr(colnames(dge.filt), 27, 28)
table(center)
samplevial <- substr(colnames(dge.filt), 14, 16)
table(samplevial)
portionanalyte <- substr(colnames(dge.filt), 18, 20)
table(portionanalyte)
plate <- substr(colnames(dge.filt), 22, 25)
table(plate)

```

From this information we can make the following observations:

  * *TSS*: Samples were collected across 4 different tissue source sites (TSS), with poor representation of one of them       (F4).
  
  * *Sample Vial*: 44 samples belong to solid tumor samples(**01 code**) whereas 39 do not (**11 code**). The 44           solid tumor samples where distributed in 3 different vials (A, B, C) whereas the 39 non tumor samples where put in      the same vial (A). 
  
  * *Portions & Analyte*: samples where distributed in different portions and analytes combinations. 
  
  * *Plates*: Samples were sequenced in different plates.

  * The analyte code of all samples is a `R` (RNA samples), as expected.
  
  * All samples were sequenced at the same center.
  
  
We are going to use the TSS as surrogate of batch effect indicator. Considering our outcome
of interest as molecular changes between sample types, tumor vs. normal, we will examine now
the cross-classification of this outcome with TSS.

```{r}
table(data.frame(TYPE=coadse.filt$type, TSS=tss))
```

We can observe that both normal and tumor tissues are well represented in all the TSS
groups, although the in the `F4` group there are a few number of samples, as said before.
Therefore, we can proceed to check if TSS is a source of expression variability.

We examine now how samples group together by hierarchical clustering and multidimensional
scaling, annotating the outcome of interest and the the surrogate of batch indicator. We
calculate again log CPM values with a higher prior count to moderate extreme fold-changes
produced by low counts. The resulting dendrogram is shown in Figure \@ref(fig:sampleClustering).

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S6: Hierarchical clustering of the samples."}
logCPM <- cpm(dge.paired, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(tss))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(coadse.filt)
outcome <- paste(substr(colnames(coadse.filt), 9, 12), as.character(coadse.filt$type), sep="-")
names(outcome) <- colnames(coadse.filt)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(tss))), fill=sort(unique(batch)))
```

We can observe that samples cluster primarily by sample type, tumor or normal. TSS seems to have
a stronger effect among the normal samples, while it distributes better among the tumor samples.
We may consider discarding samples leading to an unbalanced distribution of the outcome across batches.

In Figure \@ref(fig:mdsPlot) we show the corresponding MDS plot. Here we see more clearly that the first source of variation separates tumor from normal samples. We can also observe that two tumor samples, corresponding to individuals `KL-8404` and `KN-8427` are separated from the rest, just as it happens in the hierchical clustering. A closer examination of their corresponding MA-plots also reveals a slight dependence of expression changes on average expression. We may consider discarding these two samples and doing the MDS plot again to have a closer look to the differences among the rest of the samples and their relationship with TSS.

```{r mdsPlot, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Figure S7: Multidimensional scaling plot of the samples."}
plotMDS(dge.paired, labels=outcome, col=batch)
legend("bottomleft", paste("Batch", sort(unique(batch)), levels(factor(tss))),
       fill=sort(unique(batch)), inset=0.05)
```


## Session information

```{r, message=FALSE}
sessionInfo()
```
