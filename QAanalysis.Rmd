---
output:
  BiocStyle::html_document
---

<!---
The following chunk of code, which should not be shown in the resulting document (echo=FALSE)
sets up global processing options, such as forcing 'knitr' to stop when an error
in the R code is encountered, caching of the results in the 'cache'
directory and asking 'knitr' to figure out automatically the dependencies among
code chunks to re-calculate cached results (autodep=TRUE).

Other options could be changing the name of the directory where figures end up
('figure' by default), etc. For a full account of 'knitr' options please consult
http://yihui.name/knitr/options

At the end of the chunk a 'cat()' call is made to dump a CSS file that gives
a better look-and-feel than the knitr default one. See the source css/ieo.css
and the resulting projectTemplate.html to understand where this is being dumpted.
--->


```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)

opts_chunk$set(cache=TRUE,
               cache.path="cache/QA",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")
```

# Quality assessment

## Data import

We start importing the raw table of counts.

<!--
The option 'message=FALSE' avoid dumping R messages such as "Loading required package: methods"
into the output of the report.
-->

```{r, message=FALSE}
library(SummarizedExperiment)
coadse <- readRDS(file.path("rawCounts", "seCOAD.rds"))
coadse
```

In this RNA-seq data we have a total of 524 samples (483 tumor samples and 41 non-tumor samples). 
In order to know more about the data, we explore the `colData` column, that corresponds to clinical
variables, and their corresponding metadata.

```{r}
dim(colData(coadse))
colData(coadse)[1:5, 1:5]
mcols(colData(coadse), use.names=TRUE)
```


These metadata consists of two columns of information about the clinical variables.
One called `labelDescription` contains a succint description of the variable, often
not more self-explanatory than the variable name itself, and the other called
'CDEID' corresponds to the so-called `Common Data Element (CDE)` identifier. This
identifier can be use in https://cdebrowser.nci.nih.gov to search for further
information about the associated clinical variable using the `Advanced search`
form and the `Public ID` attribute search.

Now, explore the row (feature) data.

```{r}
rowData(se)
rowRanges(se)
```

To perform quality assessment and normalization we need first to load the
[edgeR](http://bioconductor.org/packages/edgeR) R/Bioconductor package and
create a `DGEList' object.

```{r, message=FALSE}
library(edgeR)

dge <- DGEList(counts=assays(se)$counts, genes=mcols(se))
saveRDS(dge, file.path("results", "dge.rds"))
```

Now calculate $\log_2$ CPM values of expression and put them as an additional
assay element to ease their manipulation.

```{r}
assays(se)$logCPM <- cpm(dge, log=TRUE, prior.count=0.5)
assays(se)$logCPM[1:5, 1:5]
```

## Sequencing depth

Before proceeding with any normalization or analysis step, we want to collect an overview of
the data that we are working with. Here we examine the sequencing depth by plotting the total number of
reads mapped to the genome per sample.

```{r libsizes, echo=FALSE, out.width="600px", fig.cap="Library sizes in increasing order."}
sampledepth <- round(dge.paired$sample$lib.size / 1e6, digits=1)
names(sampledepth) <- substr(colnames(coadse.paired), 6, 12)
sort(sampledepth)
par(mfrow = c(1, 1), mar = c(4, 5, 1, 1))
ord <- order(dge.paired$sample$lib.size)
barplot(dge.paired$sample$lib.size[ord]/1e+06, las = 1, ylab = "Millions of reads", xlab = "Samples",
        col = c("cyan", "orange")[coadse.paired$type] )
legend("topleft", c("Normal", "Tumor"), fill = c("cyan", "orange"), inset = 0.01)
```
In the plot we observe two main aspects that are worth paying attention to.
First, we observe that surprisingly all the tumor samples present a lower sequencing depth than the
normal samples. Even though we could not find any reliable explaination for this behaviour so far in our
research, we considered this event dispensable at this time as the sequencing depth will be taken into 
consideration during the normalization steps.
One other important aspect is that we observe that some sample present considerable differences in the sequencing depth
and specifically we can distinguish a couple of samples on the left of the graph that present 
considerably low sequencing depths: this may generate problems in further analysis of the data. 
For this reason we identify these samples by looking at the at the sample depth as shown below. 
```{r}
sampledepth <- round(dge.paired$sample$lib.size / 1e6, digits=1)
names(sampledepth) <- substr(colnames(coadse.paired), 6, 12)
sort(sampledepth)
```
Because the samples A6.2679 and A6.2682 present extremely low sequencing depths we decide to remove them from our dataset.
Since we decided to proceed with a paired analysis, when removing one sample we remove its paired one too.

```{r}
# Remove the two samples with very low sequencing depth
mask_remove_low_coverage <- substr(colnames(coadse.paired),9,12) %in% c("2679", "2682")
coadse.paired <- coadse.paired[,!mask_remove_low_coverage]
dge.paired <- dge.paired[,!mask_remove_low_coverage]
dim(coadse.paired)
```

Here we can observe again the same plot as before after having removed the said samples.

```{r}
# coverage_filtered plot
names(sampledepth) <- substr(colnames(coadse.paired), 6, 12)
sort(sampledepth)
par(mfrow = c(1, 1), mar = c(4, 5, 1, 1))
ord <- order(dge.paired$sample$lib.size)
barplot(dge.paired$sample$lib.size[ord]/1e+06, las = 1, ylab = "Millions of reads", xlab = "Samples",
        col = c("cyan", "orange")[coadse.paired$type] )
legend("topleft", c("Normal", "Tumor"), fill = c("cyan", "orange"), inset = 0.01)
```

## Gender among samples
In order to collect an even broader understanding of the dataset we then furher explore the sequencing 
depth highlighting female and male samples.

```{r}
ord <- order(dge.paired$sample$lib.size)
barplot(dge.paired$sample$lib.size[ord]/1e+06, las = 1, ylab = "Millions of reads", xlab = "Samples",
        col = c("cyan", "orange")[coadse.paired$gender[ord]] )
legend("topleft", c("Female", "Male"), fill = c("cyan", "orange"), inset = 0.01)
```
In the figure we can see that not only we have a similar number of female and male samples, but that 
their sequencing depth is quite well equilibrated as we cannot clearly identify any defined clustering event.

## Distribution of expression levels among samples

We first run a within sample normalization. 
```{r}
CPM <- t(t(dge.paired$counts)/(dge.paired$samples$lib.size/1e+06))
assays(coadse.paired)$logCPM <- cpm(dge.paired, log = TRUE, prior.count = 0.25) 
```

We are then interested in exploring the distribution of the expression levels through
all the samples in terms of logarithmic CPM units.
```{r disrRawExpAll, echo=FALSE, fig.height=4, fig.width=10, out.width="800px", fig.cap="Non-parametric density distribution of expression profiles per sample.", message=FALSE}
par(mfrow = c(1, 1), mar = c(4, 5, 1, 1))
multidensity(as.list(as.data.frame(assays(coadse.paired)$logCPM)), xlab = "log2 CPM", legend = NULL,
             main = "All samples", cex.axis = 1.2, cex.lab = 1.5, las = 1)
```
In order to provide a clearer visualization, we decided to devide the dataset into two smaller subsets, specifically 
tumor samples and normal sample. Figure \@ref(fig:distRawExpComp) shows the expression levels in terms of logCPM for tumors
and control samples separately.
```{r disrRawExpComp, echo=FALSE, fig.height=4, fig.width=10, out.width="800px", fig.cap="Non-parametric density distribution of expression profiles per sample.", message=FALSE}
tumor_mask <- coadse.paired$type == "tumor"
non_tumor_mask <- coadse.paired$type == "normal"
coadse_tumor <- coadse.paired[,tumor_mask]
coadse_control <- coadse.paired[,non_tumor_mask]
# plot divided by tumor and control for a better overview
par(mfrow = c(1, 2), mar = c(4, 5, 1, 1))
multidensity(as.list(as.data.frame(assays(coadse_tumor)$logCPM)), xlab = "log2 CPM", legend = NULL,
           main = "Tumor samples", cex.axis = 1.2, cex.lab = 1.5, las = 1)
multidensity(as.list(as.data.frame(assays(coadse_control)$logCPM)), xlab = "log2 CPM", legend = NULL,
             main = "Control samples", cex.axis = 1.2, cex.lab = 1.5, las = 1)
```

As we do not observe extreme differences in the distribution of the expression values we decide to not exclude any sample
from the dataset in this step and to proceed with furthe analyses with the current dataset.


## Distribution of expression levels among genes

We are now interested in investigating if there is any gene which has very low expression
values so that we can possibly want to exclude them from the dataset.
In order to do so, we calculate the average expression of each gene for all the samples and plot
their distribution in Figure \@ref(fig:exprdist).

```{r exprdist, echo=FALSE, out.width="400px", fig.cap="Distribution of average expression level per gene."}
avgexp <- rowMeans(assays(coadse.paired)$logCPM)
par(mfrow = c(1, 1), mar = c(4, 5, 1, 1))
hist(avgexp, xlab = expression(log[2] * "CPM"), main = "", las = 1, col = "gray")
abline(v = 0, col = "red", lwd = 2)
```

## Filtering of lowly-expressed genes

From this distribution of  \@ref(fig:exprdist) we could already visually identify a cutoff to define the too lowly expressed genes.
Nontheless, we opted for a more precise approach to calculate the cutoff.

```{r}
cpmcutoff <- round(10/min(dge.paired$sample$lib.size/1e+06), digits = 1)
sprintf("Cutoff: %s", cpmcutoff)
nsamplescutoff <- min(table(coadse.paired$gender))
mask <- rowSums(cpm(dge.paired) > cpmcutoff) >= nsamplescutoff
coadse.filt <- coadse.paired[mask, ]
dge.filt <- dge.paired[mask, ]
dim(coadse.filt)
```

Once we have identified the cutoff, we filter out the genes that are below the said cutoff.
We can visually observe which genes have been left out from the datatset in Figure \@ref(fig:filter)
```{r filter}
par(mar = c(4, 5, 1, 1))
h <- hist(avgexp, xlab = expression("Expression level (" * log[2] * "CPM)"), main = "",
          las = 1, col = "grey", cex.axis = 1.2, cex.lab = 1.5)
x <- cut(rowMeans(assays(coadse.filt)$logCPM), breaks = h$breaks)
lines(h$mids, table(x), type = "h", lwd = 10, lend = 1, col = "darkred")
legend("topright", c("All genes", "Filtered genes"), fill = c("grey", "darkred"))
```

Before proceeding with the normalization steps, we prefer to save a copy of the unnormalized data 
in case we later need to work on it again.
```{r}
saveRDS(se.filt, file.path("results", "se.filt.unnorm.rds"))
saveRDS(dge.filt, file.path("results", "dge.filt.unnorm.rds"))
```
## Normalization

Since different samples may have different RNA compositions and this could be problematic for further analyses
we need to take it into account and normalize the data.
We estimate a normalization factor for each library using the Trimmed Mean of M-Values and apply it
to our data.

```{r}
dge.filt <- calcNormFactors(dge.filt) 
assays(coadse.filt)$logCPM <- cpm(dge.filt, log=TRUE, normalized.lib.sizes=TRUE, prior.count=0.25)
```

Again, we like to keep on with the good practice of storing intermediate generated files.  

```{r}
saveRDS(se.filt, file.path("results", "coadse.filt.rds"))
saveRDS(dge.filt, file.path("results", "dge.filt.rds"))
```

## MA-plots

We now want to visualize the expression profiles of the normalized data. 
As we did previously, we opted for a subdivision of the dataset in the tumor and
normal subsets.
In Figure \@ref(fig:maPlotsTumor) we observe the MA-plots for the Tumor samples subset.
```{r maPlotsTumor, fig.height=36, fig.width=6, dpi=100, echo=FALSE, fig.cap="MA-plots of the tumor samples."}
par(mfrow=c(15, 3), mar=c(4, 5, 3, 1))
setmp <- coadse.filt[, coadse.filt$type == "tumor"]
dgetmp <- dge.filt[, coadse.filt$type == "tumor"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

In Figure \@ref(fig:maPlotsNormal) we observe the MA-plots for the Control samples subset.

```{r maPlotsNormal, fig.height=32, fig.width=6, dpi=100, echo=FALSE, fig.cap="MA-plots of the control samples."}
par(mfrow=c(15, 3), mar=c(4, 5, 3, 1))
setmp <- coadse.filt[, coadse.filt$type == "normal"]
dgetmp <- dge.filt[, coadse.filt$type == "normal"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main=samplename, las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```
As we do not see any important expression levels biases in any of the tumor and normal samples we decide to proceed to the 
next step of the analysis without modifying the dataset we work with.

## Session information

```{r, message=FALSE}
sessionInfo()
```
