---
output:
  BiocStyle::html_document
---

<!---
Because we split the analysis pipeline in different independent files,
to speed up processing it, here in the setup block we load libraries and
objects that were loaded or produced in the previously processed file,
and which are necessary in this file.
--->

```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)
library(SummarizedExperiment)
library(edgeR)
library(geneplotter)
library(GOstats)
library(xtable)
library(org.Hs.eg.db)
library(GSVAdata)
library(GSVA)
library(Category)


opts_chunk$set(cache=TRUE,
               cache.path="cache/file2",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")

se.filt <- readRDS(file.path("results", "coadse.filt.rds"))
dge.filt <- readRDS(file.path("results", "dge.filt.rds"))
```

# GSEA

The magnitude of gene expression changes may be small and very few significant DE genes will be idenified after having adjusted for multiple testing. For this reason, we want to see if there are small but consistent changes occuring for a number of genes operating in a common pathway. We go throug this workflow by assessing DE direclty at the geneset level starting from the expression data themselves. We approach this analysis by using the `GSEA algorithm`.

##coment: The idea of GSEA algorithm is to calculate for each gene an Enrichment Score (ES) as function of the changes in gene expression by the genes forming the gene set. The genes are ranked by a moderated T-statis, to see which genes have more or less DE. The ES is representative of the enrichment of those genes in the ranking. Thus, we finally compare gene sets according to the ES (non-parametric test).

## Preparation

To start with the GSEA, we start putting our expression data and the collection of gene sets from the GSVA[http://www.bioconductor.org/packages/release/data/experiment/html/GSVAdata.html] dataset `c2BroadSets` in a `GeneSetCollection` object.

```{r}
# collect gene sets
data(c2BroadSets)
gsc <- GeneSetCollection(c2BroadSets)
gsc
length(gsc) # number of gene sets in the collection
head(names(gsc)) # some of the gene sets in the collection
```

In order to reduce the amount of data to analyse, we are going to restrict the analysis to the pathways `KEGG`, `REACTOME` and `BIOCARTA`.

```{r}
gsc <- gsc[c(grep("^KEGG", names(gsc)),
grep("^REACTOME", names(gsc)), grep("^BIOCARTA", names(gsc)))]
gsc
length(gsc)
```

Now we can start our GSEA analysis, using the algorithm refered as *simple GSEA* (Irizarry et al. (2009)[https://journals.sagepub.com/doi/abs/10.1177/0962280209351908]). 

First, we need to map the identifiers from the gene sets to the identifiers of the data we are going to analyze. Furthermore, we create an incidence matrix which indicates which genes belong to what gene set.

```{r}
gsc <- mapIdentifiers(gsc, AnnoOrEntrezIdentifier(metadata(coadse.filt)$annotation))
gsc
Im <- incidence(gsc)
dim(Im)
Im[1:2, 1:10]
```
We can see that several genes are present in more than one gene set, so later on we are going to go through overlaped gen sets.

Once done it, the following step will be discard those genes that do not form part of our data and also discard all genes in our data that are not annotated to gene sets.

```{r}
Im <- Im[, colnames(Im) %in% rownames(coadse.filt)]
dim(Im)
coadse.filt <- coadse.filt[colnames(Im), ]
dim(coadse.filt)
dge.filt <- dge.filt[colnames(Im),]
dim(dge.filt)
```

As a result we have discarted almost **2600** genes that didn't belong to our data.

In order to have a sizeable list of DE genes we are going to perform a *Gene Set Enrichment Analysis* to introduce a method for pathway analysis assessing DE directly at gene set level.
# Ups! Creo que lo que evitamos haciendo GSEA justamente es hacer una sizeable list of DE genes, tal y como lo entiendo.

## DE genes

The main scope of the GSEA approach is to detect consistent and robust changes in expression within a gene set. To do so, we calculate the Enrichment Score (ES) as a z-score that may allow us to detect significantly those esmpented changes.

We decided to filter out the genesets that contain less than 10 genes. In fact, very small gene sets may induce little reliability and increase type 1 errors. Then we also calculate the zs statistic score.

```{r}
Im <- Im[rowSums(Im) >= 10, ]
tGSgenes <- tt[match(colnames(Im), rownames(tt)), "t"]
zS <- sqrt(rowSums(Im)) * (as.vector(Im %*% tGSgenes)/rowSums(Im))
length(zS)
head(zS)
```

The incidence matrix after the filtering has lost 1000 gene sets approximately.

```{r qqplot, fig.cap= "Q-Q Plot of gene set Z-scores"}
qqnorm(zS)
abline(0,1)
```

As we can observe in the Q-Q plot of figure \@ref(fig:qqplot) we can detect that the gene sets Z-scores do not follow a normal distribution which indicates a promising number of DE gene sets.
Just to have an overview we show the gene sets with the largest Z-scores.

```{r}
rnkGS <- sort(abs(zS), decreasing = TRUE)
head(rnkGS)
```

Let's define a function called ´plotGS´ to produce a scatter plot, for a given gene set, of the mean expression values comparing Tumor vs Normal phenotypes.

```{r}
plotGS <- function(se, gs, pheno, ...) {
l <- levels(colData(se)[, pheno])
idxSamples1 <- colData(se)[, pheno] == l[1]
idxSamples2 <- colData(se)[, pheno] == l[2]
exps1 <- rowMeans(assays(se)$logCPM[gs, idxSamples1])
exps2 <- rowMeans(assays(se)$logCPM[gs, idxSamples2])
rng <- range(c(exps1, exps2))
plot(exps1, exps2, pch = 21, col = "black", bg = "black", xlim = rng, ylim = rng,
xlab = l[1], ylab = l[2], ...)
abline(a = 0, b = 1, lwd = 2, col = "red")
}
```

```{r plotGS, fig.cap= "Mean expression values per gene, tumor vs normal"}
genesGS1 <- colnames(Im)[which(Im[names(rnkGS)[1], ] == 1)]
genesGS2 <- colnames(Im)[which(Im[names(rnkGS)[2], ] == 1)]
par(mfrow = c(1, 2), mar = c(4, 5, 3, 4))
plotGS(coadse.filt, genesGS1, "type", main = names(rnkGS)[1], cex.lab = 2, las = 1)
plotGS(coadse.filt, genesGS2, "type", main = names(rnkGS)[2], cex.lab = 2, las = 1)
```

As we can see in the plot \@ref(fig:plotGS) the Z-score allow us to identify those genes that are DE in one phenotype, respect to the other.

We perform one sample z-test and we compute the number of DE gene sets according to the adjusted p-value with and FDR of 1%.

```{r}
pv <- pmin(pnorm(zS), 1 - pnorm(zS))
sum(pv < 0.05)
pvadj <- p.adjust(pv, method = "fdr")
DEgs <- names(pvadj)[which(pvadj < 0.01)]
length(DEgs)
head(DEgs, n = 3)
```

As mentioned before, since gene sets can overlap, we need to take that into account before interpreting the DE gene sets. In order to do so, we use the function `computeGeneSetsOverlap` which calculates an overlap index. Then, we are going to build a table ranking of pairs of gene sets by overlaps.

```{r}
gsov <- computeGeneSetsOverlap(gsc[DEgs], rownames(coadse.filt))
trimask <- upper.tri(gsov)
rnkOv <- data.frame(gs1 = row(gsov)[trimask], gs2 = col(gsov)[trimask], ov = gsov[trimask])
rnkOv <- rnkOv[order(rnkOv$ov, decreasing = TRUE), ]
rnkOv$gs1 <- rownames(gsov)[rnkOv$gs1]
rnkOv$gs2 <- rownames(gsov)[rnkOv$gs2]
## how many pairs of gene sets are identical?
sum(rnkOv$ov == 1) 
## how many pairs of gene sets share less than 5% of the genes?
sum(rnkOv$ov < 0.05)
```
There are `r sum(rnkOv$ov == 1)` pairs of gene sets that are identical, and `r sum(rnkOv$ov < 0.05)` that share less than 5% of the genes.

If half of the genes are upregulated and the other half down-regulated, the mean shift we have calculated cancels out. This is known as a change in scale, and to detect such a change one should used this other X2-score:

```{r}
xS <- applyByCategory(tGSgenes, Im, function(x) (sum((x - mean(x))^2) - (length(x) - 1))/(2 * 
(length(x) - 1)))
```

As we did with the z-test, we are going to compute p-values and adjust them to 1% FDR for gene sets with more than about 20 genes:

```{r}
rnkGS <- sort(abs(xS), decreasing = TRUE)
head(rnkGS)
pv <- pmin(pnorm(xS), 1 - pnorm(xS))
pvadj <- p.adjust(pv)
DEgsByScale <- names(pvadj)[which(pvadj < 0.01)]
length(DEgsByScale)
length(intersect(DEgs, DEgsByScale))
setdiff(DEgsByScale, DEgs)
```

These are the top 3 gene sets selected by the χ2-score test:
```{r}
topgs1genes <- colnames(Im)[which(Im[names(rnkGS)[1], ] == 1)]
topgs2genes <- colnames(Im)[which(Im[names(rnkGS)[2], ] == 1)]
topgs3genes <- colnames(Im)[which(Im[names(rnkGS)[3], ] == 1)]
par(mfrow = c(1, 3))
plotGS(coadse.filt, topgs1genes, "type", main = names(rnkGS)[1], cex.lab = 2, las = 1)
plotGS(coadse.filt, topgs2genes, "type", main = names(rnkGS)[2], cex.lab = 2, las = 1)
plotGS(coadse.filt, topgs3genes, "type", main = names(rnkGS)[3], cex.lab = 2, las = 1)
```

#############################

Now, we are going to calculate ES independently of any phenotype and for each sample using a GSEA method unsupervised and single-sample.
For that, we are going to obtain an expression data matrix with the same number of samples but instead of genes, with gene sets and, instead of gene expression values, ES that are sample-wise gene-level summaries of expression to use them as gene expression values.

```{r}
GSexpr <- gsva(assays(coadse.filt)$logCPM, gsc,
min.sz=5, max.sz=300, verbose=FALSE)
class(GSexpr)
dim(GSexpr)
```
.############ HERE I DONT UNDERSTAND 

```{r}
svaobj <- sva(GSexpr, mod, mod0)
modSVs <- cbind(mod, svaobj$sv)
corfit <- duplicateCorrelation(GSexpr, modSVs) ## blocking variable??
fit <- lmFit(GSexpr, modSVs, correlation = corfit$consensus)
fit <- eBayes(fit)
tt <- topTable(fit, coef = 2, n = Inf)
DEgs <- rownames(tt[tt$adj.P.Val < 0.01, , drop = FALSE])
DEgs
```
So, we have 114 gene sets with type-specific expression appearing to be called DE at 1% FDR.
To see how they are differential expressed, we are going to plot two of them:

```{r}
#par(mfrow = c(1, 2))
boxplot(GSexpr["KEGG_ADIPOCYTOKINE_SIGNALING_PATHWAY", ] ~ coadse.filt$type, main = "KEGG_ADIPOCYTOKINE_SIGNALING_PATHWAY", las = 1, cex.axis = 2)
boxplot(GSexpr["KEGG_LONG_TERM_POTENTIATION", ] ~ coadse.filt$type, main = "KEGG_LONG_TERM_POTENTIATION", las = 1, cex.axis = 2)
```
```{r volc}
plot(tt$logFC, -log10(tt$P.Value), xlab="Log2 fold-change", ylab="-log10 P-value",
pch=".", cex=5, col=grey(0.75), cex.axis=1.2, cex.lab=1.5, las=1)
posx <- tt[tt$adj.P.Val < 0.01, "logFC"] ; posy <- -log10(tt[tt$adj.P.Val < 0.01, "P.Value"])
points(posx, posy, pch=".", cex=5, col="red")
text(posx, posy, rownames(tt)[tt$adj.P.Val < 0.01], pos=1)
```

The volcano plot in figure \@ref(fig:volc) points all the gene sets with type-specific genes as being differential expressed between tumor and normal.
## Session information

```{r, message=FALSE}
sessionInfo()
```
