---
output:
  BiocStyle::html_document
---

<!---
Because we split the analysis pipeline in different independent files,
to speed up processing it, here in the setup block we load libraries and
objects that were loaded or produced in the previously processed file,
and which are necessary in this file.
--->

```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)
library(SummarizedExperiment)
library(edgeR)
library(geneplotter)
library(GOstats)
library(xtable)
library(org.Hs.eg.db)
library(GSVAdata)

opts_chunk$set(cache=TRUE,
               cache.path="cache/file2",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")

se <- readRDS(file.path("rawCounts", "seCOAD.rds"))
dge <- readRDS(file.path("results", "dge.rds"))
se.filt.unnorm <- readRDS(file.path("results", "coadse.filt.unnorm.rds"))
dge.filt.unnorm <- readRDS(file.path("results", "dge.filt.unnorm.rds"))
se.filt <- readRDS(file.path("results", "coadse.filt.rds"))
dge.filt <- readRDS(file.path("results", "dge.filt.rds"))
```
NOTES :
 - We could filter out every gene which has no functional annoation
 - We could select an important type of genes and see how many important genes fall into that category

# Functional Enrichment
We perform a functional enrichment analysis on the entire collection of GO gene sets.
First we select all the genes from our paired dataset to define the gene universe. Then, we create the parameter object which contains  information about gene universe, DEgenes and the annotation package to use.
By setting the conditional(params) to true, we are computing the significance of a GO term conditional on the significance of its children. Then, we properly run the functional enrichment and we store and visualize the results in a html format.
```{r}
geneUniverse <- rownames(coadse.filt)
# Build a parameter object : information about gene universe, DEgenes and the annotation package to use.
params <- new("GOHyperGParams", geneIds=DEgenes, universeGeneIds=geneUniverse,annotation="org.Hs.eg.db", ontology="BP", pvalueCutoff=0.05, testDirection="over")
conditional(params) <- TRUE
# Run the functional enrichment analysis
hgOver <- hyperGTest(params)
hgOver
# Store and visualize  
htmlReport(hgOver, file = "gotests.html")
browseURL("gotests.html")
# store the results in a dataframe
goresults <- summary(hgOver)
```
We then have a look some of the results with the sake of having an overview of the data.
```{r}
# exploring
head(summary(hgOver))
```
```{r}
head(geneCounts(hgOver))
```
```{r}
head(universeCounts(hgOver))
```
```{r}
head(pvalues(hgOver))
```
Geneset which are either very small or that present a small number of DE genes are not really reliable. On the other hand, if the geneset is too big, its enrichment might provide little insights. In order to correct for this we filter out the goresults and only select the genesets which are neither too big nor too small.  
```{r}
goresults <- goresults[goresults$Size >= 3 & goresults$Size <= 300 & goresults$Count >= 3, ]
goresults <- goresults[order(goresults$OddsRatio, decreasing=TRUE), ]
head(goresults)
```
We now want to specifically know which are the genes that enrich each GO term. This is achieved in the next snippet and summarized in the produced html file.
```{r}
geneIDs <- geneIdsByCategory(hgOver)[goresults$GOBPID]
geneSYMs <- sapply(geneIDs, function(id) AnnotationDbi::select(org.Hs.eg.db, columns = "SYMBOL", key = id, keytype ="ENTREZID")$SYMBOL)
geneSYMs <- sapply(geneSYMs, paste, collapse = ", ")
goresults <- cbind(goresults, Genes = geneSYMs)
rownames(goresults) <- 1:nrow(goresults)
xtab <- xtable(goresults, align = "l|c|r|r|r|r|r|p{3cm}|p{3cm}|")
print(xtab, file = "goresults.html", type = "html")
browseURL("goresults.html")
```


# GSEA

The magnitude of gene expression changes may be small and very few significant DE genes will be idenified after having adjusted for multiple testing. For this reason, we want to see if there are small but consistent changes occuring for a number of genes operating in a common pathway by assessing DE direclty at the geneset level starting from the expression data themselves.


## preparation
To start with the GSEA, we start putting our expression data and the collection of gene sets in a GeneSetCollection object.
```{r}
# collect gene sets
data(c2BroadSets)
c2BroadSets <- c2BroadSets[c(grep("^KEGG", names(c2BroadSets)))]
#c2BroadSets <- c2BroadSets[c(grep("^KEGG", names(c2BroadSets)),grep("^REACTOME", names(c2BroadSets)), grep("^BIOCARTA", names(c2BroadSets)))]
gsc <- GeneSetCollection(c2BroadSets)
gsc
```
Then, we need to map the identifiers from the gene sets to the identifiers of the data we are going to analyze:
```{r}
gsc <- mapIdentifiers(gsc, AnnoOrEntrezIdentifier(metadata(coadse.filt)$annotation))
# remove genes which are not annotated to any geneset
Im <- incidence(gsc)
dim(Im)
```
Once done it, the following step will be discard those genes that do not form part of our data and also discard all genes in our data that are not annotated to gene sets.
```{r}
Im <- Im[, colnames(Im) %in% rownames(coadse.filt)]
dim(Im)
coadse.filt <- coadse.filt[colnames(Im), ]
dim(coadse.filt)
dge.filt <- dge.filt[colnames(Im),]
dim(dge.filt)
```
As a result we have discarted almost 2000 genes that didn't belong to our data


## Simple GSEA

In order to have a sizeable list of DE genes we are going to perform a Gene Set Enrichment Analysis to introduce a method for pathway analysis assessing DE directly at gene set level.


```{r}
qq <- qqnorm(tt$t)
abline(0,1)
chroutliers <- tt$chr[abs(tt$t) > 10]
text(qq$x[abs(qq$y) > 10], qq$y[abs(qq$y) > 10], chroutliers, pos = 4)
```

To have some robustness on we are interested in requiring gene sets with a minimum size like, for instance, 10 genes. Then we also the zs statistic score:
NO SE CUANTOS PONER
```{r}
Im <- Im[rowSums(Im) >= 10, ]
dim(Im)
tGSgenes <- tt[match(colnames(Im), rownames(tt)), "t"]
length(tGSgenes)
zS <- sqrt(rowSums(Im)) * (as.vector(Im %*% tGSgenes)/rowSums(Im))
length(zS)
```

To have a quick overview of how many promising gene sets could be DE, we perform a quantile-quantile (QQ) plot of gene set Z-scores:
```{r}
qqnorm(zS)
abline(0,1)
```

```{r}
rnkGS <- sort(abs(zS), decreasing = TRUE)
head(rnkGS)
```
Since under the null hypothesis of no differential expressed gene sets, the Z-scores follow a standard normal distribution, so, we can perform one sample z-test by calculating p-values:
```{r}
pv <- pmin(pnorm(zS), 1 - pnorm(zS))
sum(pv < 0.05)
```

After calculating the p-values, the gene set overlaps render those tests dependent, and therefore, multiple testing adjustment becomes conservative. But, we can still use it to have a first selection of candidate gene sets at, for instance, 1% FDR:
```{r}
pvadj <- p.adjust(pv, method = "fdr")
DEgs <- names(pvadj)[which(pvadj < 0.01)]
length(DEgs)
head(DEgs, n = 3)
```

Due to that overlap shoud be taken into account, we can calculate an overlap index with the function computeGeneSetsOverlap() and build a table ranking of pairs of gene sets by overlaps:
```{r}
library(GSVA)
gsov <- computeGeneSetsOverlap(gsc[DEgs], rownames(coadse.filt))
trimask <- upper.tri(gsov)
rnkOv <- data.frame(gs1 = row(gsov)[trimask], gs2 = col(gsov)[trimask], ov = gsov[trimask])
rnkOv <- rnkOv[order(rnkOv$ov, decreasing = TRUE), ]
rnkOv$gs1 <- rownames(gsov)[rnkOv$gs1]
rnkOv$gs2 <- rownames(gsov)[rnkOv$gs2]
## how many pairs of gene sets are identical?
sum(rnkOv$ov == 1) 
## how many pairs of gene sets share less than 5% of the genes?
sum(rnkOv$ov < 0.05)
```
If half of the genes are upregulated and the other half down-regulated, the mean shift we have calculated cancels out. To detect such a change one should used this other X2-score:
```{r}
library(Category)
xS <- applyByCategory(tGSgenes, Im, function(x) (sum((x - mean(x))^2) - (length(x) - 1))/(2 *
(length(x) - 1)))
```
As we did with the z-test, we are going to compute p-values and adjust them to 1% FDR for gene sets with more than about 20 genes:
```{r}
rnkGS <- sort(abs(xS), decreasing = TRUE)
pv <- pmin(pnorm(xS), 1 - pnorm(xS))
pvadj <- p.adjust(pv)
DEgsByScale <- names(pvadj)[which(pvadj < 0.01)]
length(DEgsByScale)
length(intersect(DEgs, DEgsByScale))
setdiff(DEgsByScale, DEgs)
```

These are the top 3 gene sets selected by the Ï‡2-score test:
```{r}
topgs1genes <- colnames(Im)[which(Im[names(rnkGS)[1], ] == 1)]
topgs2genes <- colnames(Im)[which(Im[names(rnkGS)[2], ] == 1)]
topgs3genes <- colnames(Im)[which(Im[names(rnkGS)[3], ] == 1)]
par(mfrow = c(1, 3))
plotGS <- function(se, gs, pheno, ...) {
l <- levels(colData(se)[, pheno])
idxSamples1 <- colData(se)[, pheno] == l[1]
idxSamples2 <- colData(se)[, pheno] == l[2]
exps1 <- rowMeans(assays(se)$logCPM[gs, idxSamples1])
exps2 <- rowMeans(assays(se)$logCPM[gs, idxSamples2])
rng <- range(c(exps1, exps2))
plot(exps1, exps2, pch = 21, col = "black", bg = "black", xlim = rng, ylim = rng,
xlab = l[1], ylab = l[2], ...)
abline(a = 0, b = 1, lwd = 2, col = "red")
}
plotGS(coadse.filt, topgs1genes, "type", main = names(rnkGS)[1], cex.lab = 2, las = 1)
plotGS(coadse.filt, topgs2genes, "type", main = names(rnkGS)[2], cex.lab = 2, las = 1)
plotGS(coadse.filt, topgs3genes, "type", main = names(rnkGS)[3], cex.lab = 2, las = 1)
```
#############################

Now, we are going to calculate ES independently of any phenotype and for each sample using a GSEA method unsupervised and single-sample.
For that, we are going to obtain an expression data matrix with the same number of samples but instead of genes, with gene sets and, instead of gene expression values, ES that are sample-wise gene-level summaries of expression to use them as gene expression values.

```{r}
library(GSVA)
GSexpr <- gsva(assays(coadse.filt)$logCPM, gsc,
min.sz=5, max.sz=300, verbose=FALSE)
class(GSexpr)
dim(GSexpr)
```
.############ HERE I DONT UNDERSTAND 

```{r}
svaobj <- sva(GSexpr, mod, mod0)
modSVs <- cbind(mod, svaobj$sv)
corfit <- duplicateCorrelation(GSexpr, modSVs) ## blocking variable??
fit <- lmFit(GSexpr, modSVs, correlation = corfit$consensus)
fit <- eBayes(fit)
tt <- topTable(fit, coef = 2, n = Inf)
DEgs <- rownames(tt[tt$adj.P.Val < 0.01, , drop = FALSE])
DEgs
```
So, we have 114 gene sets with type-specific expression appearing to be called DE at 1% FDR.
To see how they are differential expressed, we are going to plot two of them:

```{r}
#par(mfrow = c(1, 2))
boxplot(GSexpr["KEGG_ADIPOCYTOKINE_SIGNALING_PATHWAY", ] ~ coadse.filt$type, main = "KEGG_ADIPOCYTOKINE_SIGNALING_PATHWAY", las = 1, cex.axis = 2)
boxplot(GSexpr["KEGG_LONG_TERM_POTENTIATION", ] ~ coadse.filt$type, main = "KEGG_LONG_TERM_POTENTIATION", las = 1, cex.axis = 2)
```
```{r volc}
plot(tt$logFC, -log10(tt$P.Value), xlab="Log2 fold-change", ylab="-log10 P-value",
pch=".", cex=5, col=grey(0.75), cex.axis=1.2, cex.lab=1.5, las=1)
posx <- tt[tt$adj.P.Val < 0.01, "logFC"] ; posy <- -log10(tt[tt$adj.P.Val < 0.01, "P.Value"])
points(posx, posy, pch=".", cex=5, col="red")
text(posx, posy, rownames(tt)[tt$adj.P.Val < 0.01], pos=1)
```

The volcano plot in figure \@ref(fig:volc) points all the gene sets with type-specific genes as being differential expressed between tumor and normal.
## Session information

```{r, message=FALSE}
sessionInfo()
```
