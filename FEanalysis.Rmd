---
output:
  BiocStyle::html_document
---

<!---
Because we split the analysis pipeline in different independent files,
to speed up processing it, here in the setup block we load libraries and
objects that were loaded or produced in the previously processed file,
and which are necessary in this file.
--->

```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)
library(SummarizedExperiment)
library(edgeR)
library(geneplotter)
library(GOstats)
library(xtable)
library(org.Hs.eg.db)
library(GSVAdata)
library(GSVA)
library(Category)


opts_chunk$set(cache=TRUE,
               cache.path="cache/file2",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")

coadse.filt <- readRDS(file.path("results", "coadse.filt.rds"))
dge.filt <- readRDS(file.path("results", "dge.filt.rds"))
```

# GSEA

The magnitude of gene expression changes may be small and very few significant DE genes will be idenified after having adjusted for multiple testing. For this reason, we want to see if there are small but consistent changes occuring for a number of genes operating in a common pathway. We go throug this workflow by assessing DE genes direclty at the geneset level, starting from the expression data themselves. We approach this analysis by using the `GSEA algorithm`.

## Preparation

To start with the GSEA, we start putting our expression data and the collection of gene sets from the GSVA[http://www.bioconductor.org/packages/release/data/experiment/html/GSVAdata.html] dataset `c2BroadSets` in a `GeneSetCollection` object, as it contains curated gene sets, suggesting a good set representation for biological data analysis.

```{r}
# collect gene sets
data(c2BroadSets)
gsc <- GeneSetCollection(c2BroadSets)
gsc
length(gsc) # number of gene sets in the collection
head(names(gsc)) # some of the gene sets in the collection
```

In order to reduce the amount of data to analyse, we are going to restrict the analysis to the pathways `KEGG`, `REACTOME` and `BIOCARTA`.

```{r}
gsc <- gsc[c(grep("^KEGG", names(gsc)),
grep("^REACTOME", names(gsc)), grep("^BIOCARTA", names(gsc)))]
gsc
length(gsc)
```

Now we can start our GSEA analysis, using the algorithm refered as *simple GSEA* (Irizarry et al. (2009)[https://journals.sagepub.com/doi/abs/10.1177/0962280209351908]). 

First, we need to map the identifiers from the gene sets to the identifiers of the data we are going to analyze. Furthermore, we create an incidence matrix (Im) which indicates which genes belong to what gene set.

```{r}
gsc <- mapIdentifiers(gsc, AnnoOrEntrezIdentifier(metadata(coadse.filt)$annotation))
gsc
Im <- incidence(gsc)
dim(Im)
Im[1:2, 1:10]
```
We can see that several genes are present in more than one gene set, so later on we are going to go through overlaped gen sets.

Once done it, the following step will be discard those genes that do not form part of our data, and also discard all genes in our data that are not annotated to gene sets.

```{r}
Im <- Im[, colnames(Im) %in% rownames(all_DEgenes)]
dim(Im)
coadse.filt <- coadse.filt[colnames(Im), ]
dim(coadse.filt)
dge.filt <- dge.filt[colnames(Im),]
dim(dge.filt)
```

As a result we have discarted almost **6400** genes that didn't belong to our data.

## Simple GSEA 

In order to determine whether an *a priori* defined set of genes shows statistically significant differences between tumor vs normal phenotypes, we are going to perform a *Gene Set Enrichment Analysis* to introduce a method for pathway analysis assessing DE directly at gene set level.

The main scope of the GSEA approach is, as mentioned, to detect consistent and robust changes in expression within a gene set. To do so, we calculate the Enrichment Score (ES) as a z-score that may allow us to detect significantly those esmpented changes.

We decided to filter out the genesets that contain less than 10 genes. In fact, very small gene sets may induce little reliability and increase type I errors (false positives). Then we also calculate the z-score.

```{r}
Im <- Im[rowSums(Im) >= 5, ]
tGSgenes <- all_DEgenes[match(colnames(Im), rownames(all_DEgenes)), "t"] # calculate all t-statistics for genes in each gene set
zS <- sqrt(rowSums(Im)) * (as.vector(Im %*% tGSgenes)/rowSums(Im)) # calculating Zscore statistic
length(zS)
head(zS, n=10)
```

The incidence matrix after the filtering has lost 200 gene sets approximately.
As we can see, know we have 618 pathways that contain a total of 4174 genes. 

```{r qqplot, fig.cap= "Q-Q Plot of gene set Z-scores"}
qqnorm(zS)
abline(0,1)
```

As we can observe in the Q-Q plot of figure \@ref(fig:qqplot) we can detect that the gene sets Z-scores do not follow a normal distribution (expected but the null hypothesis of no DE gene sets), which indicates a promising number of DE gene sets.

Just to have an overview we rank the gene sets according to  Z-scores, and show in decreasing order.

```{r}
rnkGS <- sort(abs(zS), decreasing = TRUE)
head(rnkGS, n=10)
```


Let's define a function called `plotGS` to produce a scatter plot, for a given gene set, of the mean expression values comparing Tumor vs Normal phenotypes.

```{r}
plotGS <- function(se, gs, pheno, ...) {
l <- levels(colData(se)[, pheno])
idxSamples1 <- colData(se)[, pheno] == l[1]
idxSamples2 <- colData(se)[, pheno] == l[2]
exps1 <- rowMeans(assays(se)$logCPM[gs, idxSamples1])
exps2 <- rowMeans(assays(se)$logCPM[gs, idxSamples2])
rng <- range(c(exps1, exps2))
plot(exps1, exps2, pch = 21, col = "black", bg = "black", xlim = rng, ylim = rng,
xlab = l[1], ylab = l[2], ...)
abline(a = 0, b = 1, lwd = 2, col = "red")
}
```


We perform one sample z-test and compute the number of DE gene sets according to the adjusted p-value with and FDR of 1%.

```{r}
pv <- pmin(pnorm(zS), 1 - pnorm(zS))
sum(pv < 0.05)
pvadj <- p.adjust(pv, method = "fdr")
DEgs <- names(pvadj)[which(pvadj < 0.01)]
length(DEgs)
head(DEgs, n = 10)
```
After filtering by *adjusted p value* we obtained a total of 516 gene sets. 

As mentioned before, since gene sets can overlap, we need to take that into account before interpreting the DE gene sets. In order to do so, we use the function `computeGeneSetsOverlap` which calculates an overlap index. Then, we are going to build a table ranking of pairs of gene sets by overlaps.

```{r}
gsov <- computeGeneSetsOverlap(gsc[DEgs], rownames(coadse.filt))
trimask <- upper.tri(gsov)
rnkOv <- data.frame(gs1 = row(gsov)[trimask], gs2 = col(gsov)[trimask], ov = gsov[trimask])
rnkOv <- rnkOv[order(rnkOv$ov, decreasing = TRUE), ]
rnkOv$gs1 <- rownames(gsov)[rnkOv$gs1]
rnkOv$gs2 <- rownames(gsov)[rnkOv$gs2]
## how many pairs of gene sets are identical?
sum(rnkOv$ov == 1) 
## how many pairs of gene sets share less than 5% of the genes?
sum(rnkOv$ov < 0.05)
```
There are `r sum(rnkOv$ov == 1)` pairs of gene sets that are identical, and `r sum(rnkOv$ov < 0.05)` pairs that share less than 5% of the genes.

If half of the genes are upregulated and the other half down-regulated, the mean shift we have calculated cancels out. This is known as a change in scale, and to detect such a change one should used this other X^2-score:

```{r}
xS <- applyByCategory(tGSgenes, Im, function(x) (sum((x - mean(x))^2) - (length(x) - 1))/(2 * 
(length(x) - 1)))
xS
```

As we did with the z-test, we are going to compute p-values and adjust them to 1% FDR for gene sets with more than about 20 genes:

```{r}
rnkGS <- sort(abs(xS), decreasing = TRUE)
head(rnkGS, n=20)
pv <- pmin(pnorm(xS), 1 - pnorm(xS))
pvadj <- p.adjust(pv)
DEgsByScale <- names(pvadj)[which(pvadj < 0.01)]
head(setdiff(DEgsByScale, DEgs), n=5)
length(DEgsByScale)
length(intersect(DEgs, DEgsByScale))
```

These are the top 6 gene sets selected by the χ2-score test:
```{r scatter_plot, fig.align = 'center'}
topgs1genes <- colnames(Im)[which(Im[names(rnkGS)[1], ] == 1)]
genesGS1 <- rowData(coadse.filt)[topgs1genes,1]
genesGS1
  topgs2genes <- colnames(Im)[which(Im[names(rnkGS)[2], ] == 1)]
genesGS2 <- rowData(coadse.filt)[topgs2genes,1]
topgs3genes <- colnames(Im)[which(Im[names(rnkGS)[3], ] == 1)]
genesGS3 <- rowData(coadse.filt)[topgs3genes,1]
topgs4genes <- colnames(Im)[which(Im[names(rnkGS)[4], ] == 1)]
genesGS4 <- rowData(coadse.filt)[topgs4genes,1]
topgs5genes <- colnames(Im)[which(Im[names(rnkGS)[5], ] == 1)]
genesGS5 <- rowData(coadse.filt)[topgs5genes,1]
topgs6genes <- colnames(Im)[which(Im[names(rnkGS)[6], ] == 1)]
genesGS6 <- rowData(coadse.filt)[topgs6genes,1]
par(mfrow = c(2, 3), mar= c(0.5,5,2,0.5), mai=c(0.5,0.6,0.6,0.5))
plotGS(coadse.filt, topgs1genes, "type", main = names(rnkGS)[1],cex.main = 0.7, cex.lab = 2, las = 1)
plotGS(coadse.filt, topgs2genes, "type", main = names(rnkGS)[2],cex.main = 0.7, cex.lab = 2, las = 1)
plotGS(coadse.filt, topgs3genes, "type", main = names(rnkGS)[3],cex.main = 0.8, cex.lab = 2, las = 1)
plotGS(coadse.filt, topgs3genes, "type", main = names(rnkGS)[4],cex.main = 0.7, cex.lab = 2, las = 1)
plotGS(coadse.filt, topgs3genes, "type", main = names(rnkGS)[5],cex.main = 0.7, cex.lab = 2, las = 1)
plotGS(coadse.filt, topgs3genes, "type", main = names(rnkGS)[6],cex.main = 0.7, cex.lab = 2, las = 1)

```

As we can see in \@ref(fig:scatter_plot), there are represented the 6 gene sets with a higher χ2-score. 



## Session information

```{r, message=FALSE}
sessionInfo()
```
